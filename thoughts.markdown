---
title: Semiserious
---

* The problem with most programs is that somebody else wrote them.

* Ideal programming language would make writing good programs easy and bad programs hard.
  Haskell comes close, except for its support of literal strings.  You can easily do a lot of bad with literal strings.

* Java Streams have a very interesting take on referential transparency. 
  If you execute a closure twice the second call will fail.

* Rainbow Bikeshed.  If a bikeshed had all colors, how would we discuss it?   

* Lack of popularity is a necessary but not sufficient condition of doing something right.  

* Correct code does not need a typechecker.  By using Haskell I am admitting to my incompetence.

* We need type safety preventing useless error messages (e.g. "mempty").

* In Haskell, it is important to not confuse errors with exceptions. Hence the definition:  `type IOError = IOException`

* The most sought-after property of a Turing-complete language is its ability to create completely unmaintainable programs.

* A corollary of Robert C. Martin's observation that more than a half of software engineers have less than 5 years of experience is that we will keep repeating the same approaches over and over.  That period seems to be twice the Martin's number (about 10 years).

* In low-code, what else is low?

* Case against _copy and paste_:  There is only one thing worse than a bad idea, and that is a bad idea that went viral.

* Case against Deep Learning AI that writes code: garbage in, garbage out.

## Misplaced Quotes

* Properly written code never fails, hence the error handling is not necessary.
